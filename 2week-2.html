<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>2week-2</h1>
    <div>
        <b>ufw</b>
        <p>
            ufw는 iptables의 설정 도구로 복잡하지 않은 방화벽(Uncomplicated Firewall)을 말한다.
        </p>
    </div>
    <div>
        <b>service</b>
        <p>
            등록된 서비스를 기동/종료/재기동/상태조회를 할 수 있는 명령어이다.
        </p>
    </div>
    <div>
        <b>branch</b>
        <p>
            브랜치란 독립적으로 어떤 작업을 진행하기 위한 개념입니다. 
            <br>필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에, 
            <br>여러 작업을 동시에 진행할 수 있습니다.
        </p>
    </div>
    <div>
        <b>stash</b>
        <p>
        Git을 사용하다 보면 한 번쯤은 그럴 때가 있을 것이다. 우리가 주로 변경사항을 커밋할 때에는, 어떠한 기능이 완성되거나 완료되었을 때 주로 하기 때문에<br>
        지금 작업하고 있는 내용이 있는데, 다른 브랜치로 체크아웃 해야 할 때, 변경이 완료되지 않았을 때, 커밋하기는 애매한 상황이 되어버린다. <br>
        그렇다고 지금까지 변경한 내용을 커밋하지 않으면, 저장되지 않기 때문에 다시 작업해야만 한다. 이럴 때에 이용되는 것이 바로 stash다. <br>
        stash는 현재까지 Working Tree에서 작업한 내용을 커밋하지 않고, 별도의 저장소에 저장하는 명령어이다. <br>
        그러므로 stash 명령어를 실행하면, Working Tree가 HEAD의 위치로 돌아가 깨끗해진다. 이러한 점은 다른 브랜치에서 rebase를 실행하거나 
        <br>병합 시 충돌 해결에도 요긴하게 이용될 수 있다. 예를 들어 마스터 브랜치에서의 변경 사항을 rebase 했는데, 현재 브랜치의 변경 사항과 충돌한다면, 
        <br>지금까지의 변경 사항을 stash하여 저장한 뒤, rebase하여 충돌 지점을 수정한 뒤, 다시 stash에서 가져오면 병합하기에 쉬울 것이다.
        </p>
    </div>
    <div>
        <b>merge</b>
        <p>
            git branch를 다른 branch로 합치는 과정을 merge라 한다. merge의 기본 단위는 브랜치이며, git merge 명령어로는 커밋 단위로 합치기가 불가능하다.
            <br>가장 기본적인 merge는 바로 Fast Forward Merge이다. Fast Forward Merge는 현재 브랜치의 HEAD가 대상 브랜치의 HEAD까지로 옮기는 merge이다. Fast Forward Merge는 다음 명령어를 통해 가능하다. 
            <br>git switch [현재 브랜치]
            <br>git merge [대상 브랜치]
        </p>
    </div>
    <div>
        <b>conflict</b>
        <p>
            conflict는 두 브랜치의 동일한 파일에 상반된 내용이 있다는 뜻입니다. 이럴 때는 Git이 두 가지 중에서 
            <br>어떤 내용을 머지의 결과로 해야할지 모르기 때문에 사용자가 결정해줘야 하는데요. 
            <br>그래서 Git이 conflict를 발생시키는 겁니다.
            <br>conflict가 발생했을 때 2가지 방법
            <ul>
                <li>첫 번째, 일단은 머지 작업을 취소하고 원래 상태로 돌아온다.
                <li>두 번째, conflict(충돌)를 해결하고 머지를 완료한다.</li>
            </ul>
            master 브랜치, premium 브랜치가 있고, master 브랜치 - A type commit  | premium 브랜치 - B type commit
            이렇게 서로 다른 커밋을 했습니다.
            <br>HEAD가 master를 가리키고 있어 저는 master 브랜치에 있는 건데요. 이 상태에서 git merge premium 커맨드를 실행해서 master 브랜치에 premium 브랜치를 머지하겠습니다.
            <br>실행했더니 아래 그림과 같이 conflict가 발생했습니다.
            <br>자, 이 상황에서 취할 수 있는 대응 방법 1번! 일단 머지를 취소하는 방법입니다. git merge —abort  
            <br>두 번째 방법
            <br>conflict가 발생한 sample 파일을 Sublime Text라고 하는 텍스트 에디터로 열어봅니다.
            <br>지금 <<<<<<≤ HEAD 부터 ======= 까지가 master 브랜치가 가리키던 최신 커밋에서의 sample 파일의 내용이고,
            <br>======= 부터 >>>>>>> premium 까지가 premium 브랜치가 가리키던 최신 커밋에서의 sample 파일의 내용입니다.    
            <br> 여기서 할 수 있는 선택
            <ol>
                <li>Good morning!을 선택(Good morning! 텍스트만 남기고 나머지 부분 다 삭제)</li>
                <li>Good Afternoon~을 선택(Good Afternoon~ 텍스트만 남기고 나머지 부분 다 삭제)</li>
                <li>아예 충돌이 발생한 전체 부분 삭제하고 머지의 결과로 원하는 새로운 내용 입력</li>
            </ol>
    </div>
    <div>
        <b>Jenkins</b>
        <p>
            <ul>
                <li>Build를 자동화 해야하는 이유</li>
                빌드는 하루에 한번을 할 수도 있고 아예 하지 않을수도 있지만 일주일, 한달로 따지면 꽤 많이 빌드를 합니다.
                <br> 그리고 이게 1년이면 많은 시간을 투자해야합니다. 예를 들어 예전에는 java를 빌드할때 javac라는 커맨드를 직접 사용했지만 
                <br>지금은 IDEA를 이용하면 main() 메소드를 실행했을때 javac를 하고 java가 실행이 됩니다.
                <br>이렇게 반복되는 과정은 버튼 하나 or 단축키로 자동화 할 필요가 있습니다.
                <br>이유는 이 작업을 하는데도 긴장감, 집중력 등이 소모가 되고 시간도 꽤 걸리는 작업입니다.
                <br>수동으로 빌드를 계속 하게되면 이러한 이유와 편리함에 있어서 장점을 지녔기에 자동화의 필요성을 느끼게 됩니다.
                <li>젠킨스(Jenkins)의 개념</li>
                젠킨스(Jenkins)는 거의 모든 언어의 조합과 소스코드 리포지토리(Repository)에 대한 지속적인 통합(CI)과 지속적인 배포(CD)를 무료로 제공합니다.
                <br>젠킨스는 다른 일상적인 개발 작업을 자동화할 뿐 아니라 파이프라인(Pipeline)을 사용해 거의 모든 언어의 조합과 소스코드 리포지토리에 대한 지속적인 통합과 지속적인 전달 환경을 구축하기 위한 간단한 방법을 제공합니다.
                <br>젠킨스가 각각의 단계에 대한 스크립트 작성의 필요성을 없애주지는 않지만, 사용자가 쉽게 구축할 수 있는 것보다 더 빠르고 더 강력하게 빌드(Build), 테스트, 그리고 배포(deployment) 도구 등 체인 전체를 통합할 수 있는 방법을 제공해줍니다.
                <li>젠킨스 동작 방식</li>
                젠킨스는 주요 운영체제용 자바 8 WAR 아카이브와 설치 패키지, 홈브루(Homebrew) 패키지, 도커 이미지, 그리고 소스코드 형태로 사용할 수 있다. 
                <br>소스코드는 대부분 자바이며, 몇 개의 그루브(Groovy), 루비(Ruby), 그리고 앤틀러(Another Tool For Language Recognition, ANTLR) 파일이 들어 있습니다.
                <br>젠킨스를 실행하면 웹 화면을 생성하며 REST API 호출로 구동 된다.
                <li>젠키스 사용 장점</li>
                <ul>
                    <li>프로젝트의 표준 컴파일 환경에서 컴파일 오류 검출</li>
                    <li>자동화 테스트 수행</li>
                    <li>코딩 규약 준수여부 체크</li>
                    <li>프로파일링을 통해 소스 변경에 따른 성능의 변화 감시</li>
                    <li>테스트 환경에 대한 배포작업</li>
                    <li>개발 업무를 도와주는 많은 플러그인을 가지고 있음</li>
                </ul>
            </ul>
        </p>
    </div>
    <div>
        <b>ps와 kill</b>
        <p>
            ps 명령어는 리눅스의 현재 실행중인 프로세스 목록과 상태를 보여주고, 윈도우의 작업관리자와 비슷하다.
            <br>kill은 프로세스에 시그널을 보내는 명령어로 kill 뒤에 시그널 번호(-9), 프로세스 ID로 프로세스를 강제 종료할 수 있다. 
        </p>
    </div>
    <div>
        <b>df와 du</b>
        <p><ul>
            <li>df : 리눅스 시스템 전체의(마운트 된) 디스크의 여유 공간 확인하고, 파일시스템, 디스크의 크기, 사용량, 남아있는 용량, 사용률, 마운트 지점 순으로 정보를 출력한다.</li>
            <li>du : 해당 파일 및 디렉토리의 디스크 크기를 확인하는 명령어입니다. 옵션이 없으면 현재 경로의 모든 파일 크기를 MB단위로 출력합니다.</li>
        </ul></p>
    </div>
    <div>
        <b>chmod</b>
        <p>
            파일, 디렉토리의 권한을 변경하는 명령어입니다.
        </p>
    </div>
    <div>
        <b>chown</b>
        <p>
            파일, 디렉토리의 사용자, 그룹을 변경할 수 있습니다. 쉽게말해 파일의 소유권을 변경하는 것입니다.
        </p>
    </div>
    <div>
        <b>SSH 키</b>
        <p>
            <ul>
                <li>GitHub를 사용할 때 SSH 키는 왜 필요한가요?</li>
                로컬 개발 환경에서 Git을 단독으로 사용한다면 SSH가 없어도 무방합니다만, 안전하게 외부 Git 서버에서 코드를 Clone하거나 Push하려면 SSH 프로토콜을 사용합니다. GitHub처럼 인터넷을 통해 원격에서 Git 저장소를 호스팅해주는 서비스에서도 SSH 프로토콜을 지원하고 있습니다. 
                <br>GitHub 뿐만 아니라 원격 Git 저장소와 통신할 때 일반적으로 사용하는 방법입니다.
                <br>GitHub를 사용하고 싶은데 SSH 이야기가 나오니 잘 이해가 되지 않을 수도 있습니다. SSH는 Git에서도 사용하지만, 원래는 멀리 떨어져있지만 인터넷이나 네트워크를 통해 연결되어있는 컴퓨터에 안전하게 연결해주는 프로토콜로 안전한 셸(Secure Shell)이라고도 부릅니다. 
                <br>윈도(Windows)의 명령 프롬프트나 리눅스의 터미널을 사용해봤다면 셸은 이미 알고 있는 겁니다. 셸을 통해서 명령어를 입력할 수 있는데, 이 명령어를 내 컴퓨터가 아닌 네트워크로 다른 컴퓨터에 전달해주고 결과를 받아볼 수 있게 해주는 게 바로 SSH입니다.
                <br>여기서 또 하나 중요한 개념이 바로 안전(Secure)한 방식으로 통신한다는 점입니다. SSH는 사용자, 패스워드나 여러가지 인증 방법을 지원합니다만, 그 중에서도 편리성이나 안정성 면에서 추천하는 방식이 공개키 인증 방식입니다.
                <br>공개키 인증 방식을 사용하려면 공개키와 개인키를 한 쌍 만들어야합니다. 아주 간단하게 설명하면, 공개키는 접속하고자 하는 서버에 등록해놓는 용도로 사용합니다. 이름에서 알 수 있지만 공개키는 외부에 공개되어도 괜찮습니다. 
                <br>사용자는 개인키를 통해서 SSH에 접속하고, 연결 요청을 받은 SSH 서버에서는 서버에 등록된 공개키 중에 요청 받은 개인키 정보와 매치가 되는 공개키가 있는지 찾습니다. 없으면 서버 접속(인증)에 실패합니다. 등록된 공개키가 있다면? 짠, 인증에 성공하고 서버에 접속이 됩니다.
                <br>공개키는 어디에 공개되어도 문제가 없습니다만, 개인키는 비밀번호와 마찬가지로 반드시 나만 접근할 수 있도록 안전하게 보관해야합니다. 절대로 다른 사람에게 노출되어서는 안 됩니다. 개인키가 있으면 내가 공개키를 등록해놓은 SSH 서버나 Git 서버에 접속할 수 있기 때문입니다.
                <li>SSH 공개키와 개인키 만들기</li>
                그럼 SSH를 왜 사용하는지 알아봤으니, SSH 키를 직접 만들어보고 GitHub에 등록해보겠습니다.
                <br>윈도우에서는 Git을 설치하면 함께 설치되는 Git Bash를 사용합니다. macOS나 Linux에서는 터미널을 실행해서 진행합니다.
                <br>SSH 키를 만들기 전에 이미 키가 만들어져 있는지 확인해보는 것을 추천합니다. 무턱대고 키를 추가로 생성하면 기존 키가 덮어씌워질 수 있습니다.
                <br>$ cd ~/.ssh
                <br>$ ls
                <br>먼저 ~/.ssh 디렉터리로 이동해서 ls를 실행해 id_ed25519와 id_ed25519.pub 혹은 id_rsa와 id_rsa.pub 파일쌍이 있는지 확인해봅니다. 이 파일이 있다면 이미 키를 생성했던 적이 있는 것입니다. 
                <br>다른 이름으로 여러개의 키를 만들어서 사용하는 것도 물론 가능하지만, 개인키의 위치를 따로 지정해줘야해서 불편합니다.
                <br>이 파일들이 없다면 ssh-keygen으로 생성합니다. 생성 방법은 간단합니다. 아래 명령어를 실행해줍니다.
                <br>$ ssh-keygen -t ed25519 -C "your_email@example.com"
                <br>-C 옵션의 your_email@example.com은 자신의 이메일로 변경해주세요. ed25519 방식으로 동작하지 않는 경우에는 아래와 같이 RSA로 옵션을 변경해 SSH 키를 생성합니다.
                <br>$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
                <br>명령어를 실행해서 실제로 키를 만들어보겠습니다.
                <br>$ ssh-keygen -t ed25519 -C "lainyzine.com@gmail.com"
                <br>Generating public/private ed25519 key pair.
                <br>Enter file in which to save the key (/Users/lainyzine/.ssh/id_ed25519):
                <br>첫 번째로 저장하고자하는 위치를 물어봅니다. 다른 위치를 지정하는 것도 가능하지만 여기서는 기본값을 사용합니다.
                <br>Enter passphrase (empty for no passphrase):
                <br>Enter same passphrase again:
                <br>다음으로 SSH 키에 대한 비밀번호를 추가로 지정할지 물어봅니다. 패스워드를 설정해도 되고, 추가 패스워드 없이 사용하려면 엔터를 두 번 입력해줍니다. 
                <br>(추가 패스워드는 나중에 지정하는 것도 가능하지만, GitHub에서는 공식적으로 패스워드 설정을 권장하고 있습니다).
                <br><br>
                <br>Your identification has been saved in /Users/lainyzine/.ssh/id_ed25519.
                <br>Your public key has been saved in /Users/lainyzine/.ssh/id_ed25519.pub.
                <br>The key fingerprint is:
                <br>SHA256:MRR2EWPjezAxwlrxCgfqjq43CJjtZVl8Heo5YU/912I lainyzine.com@gmail.com
                <br>The key's randomart image is:
                <br>+--[ED25519 256]--+
                <br>|      ..*oXo     |
                <br>|     . +o*.=     |
                <br>|    ...o+o=o     |
                <br>|   .  +o=+o+.    |
                <br>|.o  .o +S=. ..  .|
                <br>|+ .o+   + ..  E o|
                <br>|.o.o.    .   . o |
                <br>|..+              |
                <br>|.o..             |
                <br>+----[SHA256]-----+
                <br>그럼 SSH 키가 생성되었습니다. 설명을 잘 읽어보면 개인키는 /Users/lainyzine/.ssh/id_ed25519에, 공개키는 /Users/lainyzine/.ssh/id_ed25519.pub에 저장되었습니다. 
                <br>RSA 방식으로 키를 생성하는 경우 기본 파일 이름은 id_rsa, id_rsa.pub가 됩니다.
            </ul>

        </p>
    </div>
    
</body>
</html>